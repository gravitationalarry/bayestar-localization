#!/usr/bin/env python
#
# Copyright (C) 2012  Leo Singer
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
"""
Listen for new events from lvalert and perform sky localization.
"""
__author__ = "Leo Singer <leo.singer@ligo.org>"


#
# Command line interface
#

from optparse import Option, OptionParser
opts, args = OptionParser(usage = "%prog [options] [GRACEID]",
    option_list = []
).parse_args()

# Late imports

import io
import os
import sys
import shutil
import time
from cStringIO import StringIO
import tempfile
import bayestar.io
import subprocess
import ligo.gracedb.rest
import ligo.lvalert.utils


#
# Logging
#

import logging
logging.basicConfig(level=logging.INFO)
log = logging.getLogger('BAYESTAR')

class GraceDbLogStream(object):
    def __init__(self, gracedb, graceid):
        self.gracedb = gracedb
        self.graceid = graceid
    def flush(self):
        pass
    def write(self, text):
        self.gracedb.writeLog(graceid, text.replace("\n", "<br/>"))

class GraceDbLogFormatter(logging.Formatter):
    def __init__(self):
        logging.Formatter.__init__(self, logging.BASIC_FORMAT)
    def format(self, record):
        s = logging.Formatter.format(self, record)
        return '<div style="white-space:pre-wrap">' + s.strip("\n") + '</div>'

class GraceDbLogHandler(logging.StreamHandler):
    def __init__(self, gracedb, graceid):
        stream = GraceDbLogStream(gracedb, graceid)
        logging.StreamHandler.__init__(self, stream)
        self.formatter = GraceDbLogFormatter()


#
# Functions
#

def wait_for_download(gracedb, graceid, filename):
    timeout = 1
    log.debug("%s:waiting for file to arrive", filename)
    while True:
        try:
            fileobj = gracedb.files(graceid, filename)
        except ligo.gracedb.rest.HTTPError:
            log.debug('%s:not found, sleeping for %d seconds', filename, timeout)
            time.sleep(timeout)
            timeout *= 2
        else:
            log.info('%s:downloaded', filename)
            return fileobj

#
# Parse input
#

if len(args) > 0:
    # Manual start
    lvadata = {'uid': args[0], 'alert_type': 'new'}
else:
    # Read LVAlert data from stdin
    lvadata = ligo.lvalert.utils.get_LVAdata_from_stdin(sys.stdin, as_dict=True)


#
# Act on input
#

graceid = lvadata['uid']
alert_type = lvadata['alert_type']
log.info("received lvalert event for uid='%s' of type '%s'", graceid, alert_type)

if alert_type == 'new':
    # Fire up a GraceDb client
    gracedb = ligo.gracedb.rest.GraceDb()

    # Send log messages to GraceDb too
    logging.root.addHandler(GraceDbLogHandler(gracedb, graceid))

    # Produce log message for any otherwise uncaught exception
    try:
        # download coinc.xml
        coinc_file = wait_for_download(gracedb, graceid, "coinc.xml")
        # download psd.xml.gz
        psd_file = wait_for_download(gracedb, graceid, "psd.xml.gz")

        # perform sky localization
        from bayestar.ligolw_sky_map import gracedb_sky_map
        log.info("starting sky localization")
        sky_map, epoch, elapsed_time = gracedb_sky_map(coinc_file, psd_file, "TaylorF2threePointFivePN", 10, 100, 200, "uniform in log distance")
        log.info("sky localization complete")

        # upload FITS file
        fitsdir = tempfile.mkdtemp()
        try:
            fitspath = os.path.join(fitsdir, "skymap.fits.gz")
            bayestar.io.write_skymap(fitspath, skymap=sky_map, gps=float(epoch))
            # FIXME: use REST interface once it supports gzipped files
            subprocess.check_call(["gracedb", "upload", graceid, fitspath])
        finally:
            shutil.rmtree(fitsdir)

        # write EM_READY label
        gracedb.writeLabel(graceid, "EM_READY")
    except:
        log.exception("sky localization failed")
        raise
else:
    # LVAlert notification was not intended for us
    log.info("ignoring")
