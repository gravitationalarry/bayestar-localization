#!/usr/bin/env python
#
# Copyright (C) 2012  Leo Singer
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
"""
Script for Monte Carlo sky localization study.
"""
__author__ = "Leo Singer <leo.singer@ligo.org>"


# Command line interface.
from optparse import Option, OptionParser
opts, args = OptionParser(
    option_list = [
        Option("--nside", "-n", type=int, default=128,
            help="HEALPix lateral resolution (default=128)")
    ]
).parse_args()

infilename = args[0]


# Python standard library imports.
import os
import time

# LIGO-LW XML imports.
from pylal import llwapp as ligolw_app
from pylal import ligolw_inspinjfind
from glue.ligolw import table as ligolw_table
from pylal import ligolw_thinca
from glue.ligolw import utils as ligolw_utils
from glue.ligolw import lsctables

# glue, LAL and pylal imports.
from pylal.xlal import inject
from pylal import date
import swiglal
import swiglalsimulation

# BAYESTAR imports.
from bayestar import io
import bayestar_localization
from bayestar_localization import misc

# Other imports.
import healpy as hp
import numpy as np

# Read injection file.
xmldoc = ligolw_utils.load_filename(infilename,
    gz=(os.path.splitext(infilename) == '.gz'))

def find_injection(sky_map, true_ra, true_dec):
    """
    Given a sky map and the true right ascension and declination (in radians),
    find the smallest area in deg^2 that would have to be searched to find the
    source, the smallest posterior mass, and the angular offset in degrees from
    the true location to the maximum (mode) of the posterior.
    """

    # Compute the HEALPix lateral resolution parameter for this sky map.
    npix = len(sky_map)
    nside = hp.npix2nside(npix)

    # Convert from ra, dec to conventional spherical polar coordinates.
    true_theta = 0.5 * np.pi - true_dec
    true_phi = true_ra

    # Find the HEALPix pixel index of the mode of the posterior and of the
    # true sky location.
    mode_pix = np.argmax(sky_map)
    true_pix = hp.ang2pix(nside, true_theta, true_phi)

    # Compute the Cartesian unit vector of the mode and true locations.
    mode_vec = np.asarray(hp.pix2vec(nside, mode_pix))
    true_vec = np.asarray(hp.ang2vec(true_theta, true_phi))

    # Sort the pixels in the sky map by descending posterior probability and
    # form the cumulative sum.  Record the total value.
    indices = np.argsort(sky_map)[::-1]
    cum_sky_map = np.cumsum(sky_map[indices])

    # Find the index of the true location in the cumulative distribution.
    idx = (i for i, pix in enumerate(indices) if pix == true_pix).next()

    # Find the smallest area that would have to be searched to find the true
    # location.
    searched_area = (idx + 1) * hp.nside2pixarea(nside, degrees=True)

    # Find the smallest posterior mass that would have to be searched to find
    # the true location.
    searched_prob = cum_sky_map[idx]

    # Permute the cumulative distribution so that it is indexed the same way
    # as the original sky map.
    cum_sky_map[indices] = cum_sky_map

    # Find the angular offset between the mode and true locations.
    offset = np.rad2deg(np.arccos(np.dot(true_vec, mode_vec)))

    # Done.
    return searched_area, searched_prob, offset


outfile1 = open("toa.out", "w")
outfile2 = open("toa_snr.out", "w")

header = "elapsed_time searched_area searched_prob offset"
print >>outfile1, header
print >>outfile2, header

# Look up coinc_def ids.
coinc_def = ligolw_thinca.InspiralCoincDef
coinc_def_id = ligolw_app.get_coinc_def_id(xmldoc, coinc_def.search, coinc_def.search_coinc_type, create_new=False)
coinc_def = ligolw_inspinjfind.InspiralSCExactCoincDef
sim_coinc_def_id = ligolw_app.get_coinc_def_id(xmldoc, coinc_def.search, coinc_def.search_coinc_type, create_new=False)

# Look up coinc_table and coinc_map_table.
coinc_table = ligolw_table.get_table(xmldoc, lsctables.CoincTable.tableName)
coinc_map_table = ligolw_table.get_table(xmldoc, lsctables.CoincMapTable.tableName)


def events_for_coinc_event_id(coinc_event_id):
    for coinc_map in coinc_map_table:
        if coinc_map.coinc_event_id == coinc_event_id:
            for row in ligolw_table.get_table(xmldoc, coinc_map.table_name):
                column_name = coinc_map.event_id.column_name
                if getattr(row, column_name) == coinc_map.event_id:
                    yield coinc_map.event_id, row

def complex_from_polar(r, phi):
    return r * (np.cos(phi) + np.sin(phi) * 1j)

# Loop over all coinc_event <-> sim_inspiral coincs.
for sim_coinc in coinc_table:

    # If this is not a coinc_event <-> sim_inspiral coinc, skip it.
    if sim_coinc.coinc_def_id != sim_coinc_def_id:
        continue

    # Locate the sim_inspiral and coinc events.
    sim_inspiral = None
    coinc = None
    for event_id, event in events_for_coinc_event_id(sim_coinc.coinc_event_id):
        if event_id.table_name == ligolw_table.StripTableName(lsctables.SimInspiralTable.tableName):
            if sim_inspiral is not None:
                raise RuntimeError("Found more than one matching sim_inspiral entry")
            sim_inspiral = event
        elif event_id.table_name == ligolw_table.StripTableName(lsctables.CoincTable.tableName):
            if coinc is not None:
                raise RuntimeError("Found more than one matching coinc entry")
            coinc = event
        else:
            raise RuntimeError("Did not expect coincidence to contain an event of type '%s'" % event_id.table_name)

    sngl_inspirals = list(event
        for event_id, event in events_for_coinc_event_id(coinc.coinc_event_id))
    ifos = [sngl_inspiral.ifo for sngl_inspiral in sngl_inspirals]

    # Unpack some values from the rows in the tables.
    m1 = sngl_inspirals[0].mass1
    m2 = sngl_inspirals[0].mass2
    f_low = sim_inspiral.f_lower # FIXME: better to get this elsewhere, but it's not stored in the sngl_inspiral table.
    f_high = 4400 / (m1 + m2)
    ra = sim_inspiral.longitude
    dec = sim_inspiral.latitude
    mchirp = misc.mchirp(m1, m2)

    # Extract SNRs and TOAs from sngl_inspiral rows.
    snrs = np.asarray([complex_from_polar(sngl_inspiral.snr, sngl_inspiral.coa_phase)
        for sngl_inspiral in sngl_inspirals])
    toas_ns = np.asarray([sngl_inspiral.get_end().ns()
        for sngl_inspiral in sngl_inspirals])
    mean_toa_ns = sum(toas_ns) // len(toas_ns)
    toas = 1e-9 * (toas_ns - mean_toa_ns)
    epoch = date.XLALINT8NSToGPS(mean_toa_ns)
    gmst = date.XLALGreenwichMeanSiderealTime(epoch)

    # Get SNR=1 horizon distances for each detector.
    horizons = np.asarray([
        misc.get_horizon_distance(ifo, mchirp, f_low, f_high)
        for ifo in ifos])

    # Get effective bandwidths for each detector.
    bandwidths = np.asarray([
        misc.get_effective_bandwidth(ifo, f_low, f_high)
        for ifo in ifos])

    # Estimate TOA uncertainty (squared) using CRLB evaluated at MEASURED
    # values of the SNRs.
    s2_toas = misc.toa_uncertainty(snrs, bandwidths) ** 2

    # Look up physical parameters for detector.
    detectors = [swiglalsimulation.XLALInstrumentNameToLALDetector(str(ifo))
        for ifo in ifos]
    responses = [det.response for det in detectors]
    locations = [det.location for det in detectors]


    #
    # TOA-only sky localization
    #

    # Time and run sky localization.
    start_time = time.time()
    sky_map = bayestar_localization.sky_map_tdoa(opts.nside, gmst, toas, s2_toas, locations)
    end_time = time.time()

    # Compute elapsed time.
    elapsed_time = end_time - start_time

    # Calculate how well the injection is recovered.
    searched_area, searched_prob, offset = find_injection(sky_map, ra, dec)

    # Print results to output file.
    print >>outfile1, elapsed_time, searched_area, searched_prob, offset

    io.write_skymap('%s.toa.fits.gz' % sim_inspiral.simulation_id,
        skymap=sky_map, gps=float(epoch))


    #
    # TOA+SNR sky localization
    #

    # Time and run sky localization.
    start_time = time.time()
    sky_map = bayestar_localization.sky_map_tdoa_snr(opts.nside, gmst, toas, snrs, s2_toas, responses, locations, horizons)
    end_time = time.time()

    # Compute elapsed time.
    elapsed_time = end_time - start_time

    # Calculate how well the injection is recovered.
    searched_area, searched_prob, offset = find_injection(sky_map, ra, dec)

    # Print results to output file.
    print >>outfile2, elapsed_time, searched_area, searched_prob, offset

    io.write_skymap('%s.toa_snr.fits.gz' % sim_inspiral.simulation_id,
        skymap=sky_map, gps=float(epoch))


# Close output files
outfile1.close()
outfile2.close()
